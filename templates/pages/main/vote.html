{% extends 'base/base.html' %}

{% block title %}Vote: {{ match_data.song1.title }} vs {{ match_data.song2.title }}{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row justify-content-center">
        <div class="col-12 col-xl-10">
            <!-- Progress Bar -->
            <div class="mb-3 mb-md-4">
                <div class="d-flex flex-column flex-sm-row justify-content-between align-items-start align-items-sm-center mb-2">
                    <h5 class="mb-1 mb-sm-0">{{ match_data.round_name }}</h5>
                    <small class="text-muted">Match {{ match_data.match_progress }}</small>
                </div>
                <div class="progress">
                    <div class="progress-bar" role="progressbar" style="width: {{ match_data.progress.percentage }}%">
                        <span class="d-none d-sm-inline">{{ match_data.progress.percentage }}%</span>
                    </div>
                </div>
                <small class="text-muted d-block mt-1">{{ match_data.progress.completed_matches }}/{{ match_data.progress.total_matches }} matches completed</small>
            </div>

            <!-- Match Container -->
            <div class="match-container">
                <div class="text-center mb-3 mb-md-4">
                    <h2 class="h3 h-md-2">Choose Your Favorite</h2>
                    <p class="mb-0 d-none d-sm-block">Listen to both songs and pick the one you prefer</p>
                    <p class="mb-0 d-sm-none small">Tap to choose your favorite song</p>
                </div>

                <div class="row voting-container" id="votingContainer">
                    <!-- Song 1 -->
                    <div class="col-12 col-md-5 mb-3 mb-md-0" id="song1Container">
                        <div class="song-card card h-100" data-song-id="{{ match_data.song1.id }}" onclick="selectSong('{{ match_data.song1.id }}')" 
                             onmouseover="highlightCard(this)" onmouseout="clearHighlight(this)" id="song1Card" 
                             role="button" tabindex="0" aria-label="Vote for {{ match_data.song1.title }}">
                            <div class="card-body text-center p-3">
                                {% if match_data.song1.background_image_url %}
                                <img src="{{ match_data.song1.background_image_url }}" 
                                     class="img-fluid rounded mb-3 song-image" 
                                     style="max-height: 200px; object-fit: cover; width: 100%;"
                                     alt="Background for {{ match_data.song1.title }}"
                                     loading="lazy">
                                {% else %}
                                <div class="bg-light rounded mb-3 d-flex align-items-center justify-content-center song-placeholder" 
                                     style="height: 200px; min-height: 120px;">
                                    <i class="fas fa-music fa-3x text-muted"></i>
                                </div>
                                {% endif %}
                                
                                <h4 class="card-title h5 h-md-4">{{ match_data.song1.title }}</h4>
                                {% if match_data.song1.original_song %}
                                <p class="card-text text-muted small">Original: {{ match_data.song1.original_song }}</p>
                                {% endif %}
                                
                                {% if 'drive.google.com' in match_data.song1.audio_url %}
                                <!-- Google Drive audio with loading state -->
                                <div class="audio-container mb-3" onclick="event.stopPropagation();">
                                    <div class="audio-loading-state" id="audioLoading1">
                                        <div class="d-flex align-items-center justify-content-center p-2">
                                            <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                                            <small class="text-muted">Loading audio...</small>
                                        </div>
                                    </div>
                                    <iframe id="audioFrame1" 
                                            data-src="{{ match_data.song1.audio_url }}" 
                                            width="100%" height="60" frameborder="0" 
                                            allow="autoplay; encrypted-media"
                                            class="audio-player google-drive-audio d-none"
                                            title="Audio player for {{ match_data.song1.title }}"
                                            loading="lazy">
                                    </iframe>
                                    <button id="audioFallback1" class="btn btn-outline-primary btn-sm audio-fallback d-none" 
                                            onclick="loadAudioFrame('audioFrame1', '{{ match_data.song1.audio_url }}', 'audioLoading1', 'audioFallback1')">
                                        <i class="fas fa-play"></i> Click to load audio
                                    </button>
                                </div>
                                {% else %}
                                <!-- Standard audio player -->
                                <audio controls class="audio-player w-100" preload="metadata" onclick="event.stopPropagation();">
                                    <source src="{{ match_data.song1.audio_url }}" type="audio/mpeg">
                                    Your browser does not support the audio element.
                                </audio>
                                {% endif %}
                                
                                <div class="mt-2 mt-md-3 text-muted">
                                    <small class="d-none d-sm-inline"><i class="fas fa-hand-pointer"></i> Click to choose this song</small>
                                    <small class="d-sm-none"><i class="fas fa-hand-pointer"></i> Tap to vote</small>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- VS Text -->
                    <div class="col-12 col-md-2 d-flex align-items-center justify-content-center my-2 my-md-0" id="vsContainer">
                        <div class="vs-text">VS</div>
                    </div>

                    <!-- Song 2 -->
                    <div class="col-12 col-md-5 mb-3 mb-md-0" id="song2Container">
                        <div class="song-card card h-100" data-song-id="{{ match_data.song2.id }}" onclick="selectSong('{{ match_data.song2.id }}')" 
                             onmouseover="highlightCard(this)" onmouseout="clearHighlight(this)" id="song2Card"
                             role="button" tabindex="0" aria-label="Vote for {{ match_data.song2.title }}">
                            <div class="card-body text-center p-3">
                                {% if match_data.song2.background_image_url %}
                                <img src="{{ match_data.song2.background_image_url }}" 
                                     class="img-fluid rounded mb-3 song-image" 
                                     style="max-height: 200px; object-fit: cover; width: 100%;"
                                     alt="Background for {{ match_data.song2.title }}"
                                     loading="lazy">
                                {% else %}
                                <div class="bg-light rounded mb-3 d-flex align-items-center justify-content-center song-placeholder" 
                                     style="height: 200px; min-height: 120px;">
                                    <i class="fas fa-music fa-3x text-muted"></i>
                                </div>
                                {% endif %}
                                
                                <h4 class="card-title h5 h-md-4">{{ match_data.song2.title }}</h4>
                                {% if match_data.song2.original_song %}
                                <p class="card-text text-muted small">Original: {{ match_data.song2.original_song }}</p>
                                {% endif %}
                                
                                {% if 'drive.google.com' in match_data.song2.audio_url %}
                                <!-- Google Drive audio with lazy loading -->
                                <div class="audio-container mb-3" onclick="event.stopPropagation();">
                                    <div class="audio-lazy-state" id="audioLazy2">
                                        <button class="btn btn-outline-secondary btn-sm w-100" 
                                                onclick="loadSecondAudio('{{ match_data.song2.audio_url }}', this)">
                                            <i class="fas fa-headphones me-1"></i> Load Audio Player
                                            <small class="d-block text-muted">Click to load (saves bandwidth)</small>
                                        </button>
                                    </div>
                                    <div class="audio-loading-state d-none" id="audioLoading2">
                                        <div class="d-flex align-items-center justify-content-center p-2">
                                            <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                                            <small class="text-muted">Loading audio...</small>
                                        </div>
                                    </div>
                                    <iframe id="audioFrame2" 
                                            width="100%" height="60" frameborder="0" 
                                            allow="autoplay; encrypted-media"
                                            class="audio-player google-drive-audio d-none"
                                            title="Audio player for {{ match_data.song2.title }}"
                                            loading="lazy">
                                    </iframe>
                                    <button id="audioFallback2" class="btn btn-outline-primary btn-sm audio-fallback d-none" 
                                            onclick="loadAudioFrame('audioFrame2', '{{ match_data.song2.audio_url }}', 'audioLoading2', 'audioFallback2')">
                                        <i class="fas fa-play"></i> Click to load audio
                                    </button>
                                </div>
                                {% else %}
                                <!-- Standard audio player -->
                                <audio controls class="audio-player w-100" preload="metadata" onclick="event.stopPropagation();">
                                    <source src="{{ match_data.song2.audio_url }}" type="audio/mpeg">
                                    Your browser does not support the audio element.
                                </audio>
                                {% endif %}
                                
                                <div class="mt-2 mt-md-3 text-muted">
                                    <small class="d-none d-sm-inline"><i class="fas fa-hand-pointer"></i> Click to choose this song</small>
                                    <small class="d-sm-none"><i class="fas fa-hand-pointer"></i> Tap to vote</small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="text-center mt-3 mt-md-4">
                    <a href="{% url 'home' %}" class="btn btn-light btn-sm">
                        <i class="fas fa-home"></i> <span class="d-none d-sm-inline">Back to Home</span><span class="d-sm-none">Home</span>
                    </a>
                </div>
            </div>

        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// Tournament Resource Cache Manager
class TournamentCache {
    constructor() {
        this.imageCache = new Map();
        this.audioCache = new Map();
        this.preloadedImages = new Set();
        // Audio caching removed - preloadedAudio Set no longer needed
        this.maxCacheSize = 256; // Increased to handle 128 songs + extras
        this.tournamentCacheSize = 128; // Never cleanup tournament resources
        this.sessionData = null;
        this.tournamentSongIds = new Set(); // Track tournament songs
        this.isTournamentActive = true; // Don't cleanup during tournament
    }
    
    // Get all songs from session bracket data
    async loadSessionData() {
        try {
            const response = await fetch('/game/api/session-songs/', {
                headers: {
                    'X-CSRFToken': '{{ csrf_token }}'
                }
            });
            if (response.ok) {
                this.sessionData = await response.json();
                // Track all tournament song IDs to prevent cleanup
                this.sessionData.forEach(song => {
                    this.tournamentSongIds.add(song.background_image_url);
                    this.tournamentSongIds.add(song.audio_url);
                });
                console.log('Session data loaded:', this.sessionData.length, 'total songs');
                console.log('Tournament cache protection enabled for', this.tournamentSongIds.size, 'resources');
                return this.sessionData;
            }
        } catch (error) {
            console.warn('Could not load session data for preloading:', error);
        }
        return null;
    }
    
    // Preload images with lazy loading
    preloadImages(songs, priority = false) {
        const imagesToLoad = songs.filter(song => 
            song.background_image_url && 
            !this.preloadedImages.has(song.background_image_url)
        );
        
        if (imagesToLoad.length === 0) return Promise.resolve();
        
        console.log(`Preloading ${imagesToLoad.length} images (priority: ${priority})`);
        
        const loadPromises = imagesToLoad.map(song => {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    this.imageCache.set(song.background_image_url, img);
                    this.preloadedImages.add(song.background_image_url);
                    resolve();
                };
                img.onerror = () => {
                    console.warn('Failed to preload image:', song.background_image_url);
                    resolve(); // Don't block on errors
                };
                
                // Add loading attribute for better performance
                img.loading = priority ? 'eager' : 'lazy';
                img.src = song.background_image_url;
            });
        });
        
        return Promise.allSettled(loadPromises);
    }
    
    // Note: Audio caching removed - Google Drive audio cannot be effectively cached
    // Only image caching is maintained for performance benefits
    
    // Preload next round songs with priority
    async preloadNextRoundSongs() {
        const currentMatch = {{ debug_info.current_match }};
        const currentRound = {{ debug_info.current_round }};
        
        // Calculate which songs might appear in next matches
        const nextSongs = this.predictNextRoundSongs(currentMatch, currentRound);
        
        if (nextSongs.length > 0) {
            console.log('Preloading next round songs:', nextSongs.length);
            await this.preloadImages(nextSongs, true);
            // Audio preloading removed - only images are cached
        }
    }
    
    // Predict which songs might appear in upcoming matches
    predictNextRoundSongs(currentMatch, currentRound) {
        // This is a simplified prediction - in a real implementation,
        // you'd analyze the bracket structure to predict likely winners
        const currentSongs = [
            {
                background_image_url: '{{ match_data.song1.background_image_url }}',
                audio_url: '{{ match_data.song1.audio_url }}'
            },
            {
                background_image_url: '{{ match_data.song2.background_image_url }}',
                audio_url: '{{ match_data.song2.audio_url }}'
            }
        ];
        
        return currentSongs.filter(song => song.background_image_url || song.audio_url);
    }
    
    // Background preloading for remaining tournament songs
    async startBackgroundPreloading() {
        const allSongs = await this.loadSessionData();
        if (!allSongs) return;
        
        // Preload in chunks to avoid overwhelming the browser
        const chunkSize = 10;
        const chunks = [];
        
        for (let i = 0; i < allSongs.length; i += chunkSize) {
            chunks.push(allSongs.slice(i, i + chunkSize));
        }
        
        // Process chunks with delays
        for (let i = 0; i < chunks.length; i++) {
            setTimeout(() => {
                this.preloadImages(chunks[i], false);
                // Audio preloading removed - only images are cached
            }, i * 2000); // 2 second delay between chunks
        }
    }
    
    // Clear cache if it gets too large (but protect tournament resources)
    clearOldCache() {
        if (this.imageCache.size > this.maxCacheSize && !this.isTournamentActive) {
            // Only delete non-tournament resources
            const keysToDelete = Array.from(this.imageCache.keys())
                .filter(key => !this.tournamentSongIds.has(key))
                .slice(0, 50);
            
            keysToDelete.forEach(key => {
                this.imageCache.delete(key);
                this.preloadedImages.delete(key);
            });
            
            if (keysToDelete.length > 0) {
                console.log('Cleared', keysToDelete.length, 'non-tournament cache entries');
            }
        } else if (this.isTournamentActive) {
            console.log('üîí Cache cleanup skipped - tournament active, protecting', this.tournamentSongIds.size, 'resources');
        }
    }
    
    // Get cache statistics
    getCacheStats() {
        return {
            images_cached: this.preloadedImages.size,
            total_cache_size: this.imageCache.size,
            cache_hit_rate: this.preloadedImages.size / Math.max(1, this.sessionData?.length || 1)
        };
    }
    
    // Log cache performance
    logCachePerformance() {
        const stats = this.getCacheStats();
        console.log('üìä Cache Performance:', {
            'üñºÔ∏è Images cached': stats.images_cached,
            'üíæ Total cache size': stats.total_cache_size,
            'üéØ Cache efficiency': `${(stats.cache_hit_rate * 100).toFixed(1)}%`,
            'üîí Tournament protection': this.isTournamentActive ? 'ACTIVE' : 'DISABLED'
        });
    }
    
    // Save cache state to localStorage for cross-page persistence
    saveToLocalStorage() {
        try {
            const cacheData = {
                preloadedImages: Array.from(this.preloadedImages),
                tournamentSongIds: Array.from(this.tournamentSongIds),
                sessionData: this.sessionData,
                isTournamentActive: this.isTournamentActive,
                timestamp: Date.now()
            };
            localStorage.setItem('tournamentCache', JSON.stringify(cacheData));
        } catch (error) {
            console.warn('Could not save cache to localStorage:', error);
        }
    }
    
    // Load cache state from localStorage
    loadFromLocalStorage() {
        try {
            const cacheData = JSON.parse(localStorage.getItem('tournamentCache'));
            if (cacheData && (Date.now() - cacheData.timestamp) < 24 * 60 * 60 * 1000) { // 24 hours
                this.preloadedImages = new Set(cacheData.preloadedImages || []);
                this.tournamentSongIds = new Set(cacheData.tournamentSongIds || []);
                this.sessionData = cacheData.sessionData;
                this.isTournamentActive = cacheData.isTournamentActive !== false;
                
                console.log('üîÑ Restored cache from localStorage:', {
                    images: this.preloadedImages.size,
                    protected_resources: this.tournamentSongIds.size
                });
                return true;
            }
        } catch (error) {
            console.warn('Could not load cache from localStorage:', error);
        }
        return false;
    }
    
    // Get cached image if available
    getCachedImage(url) {
        return this.imageCache.get(url);
    }
    
    // Check if resource is cached
    isResourceCached(url, type = 'image') {
        if (type === 'image') {
            return this.preloadedImages.has(url);
        } else if (type === 'audio') {
            return false; // Audio caching disabled
        }
        return false;
    }
}

// Initialize cache manager and make it globally available
const tournamentCache = new TournamentCache();

// Make cache globally available for other pages
window.tournamentCache = tournamentCache;

// Debug: Log the match data to console
console.log('Match data received:', {
    session_id: '{{ match_data.session_id }}',
    current_match: {{ debug_info.current_match }},
    current_round: {{ debug_info.current_round }},
    last_updated: '{{ debug_info.last_updated }}',
    page_generated_at: '{{ debug_info.page_generated_at }}',
    song1_id: '{{ match_data.song1.id }}',
    song2_id: '{{ match_data.song2.id }}',
    song1_title: '{{ match_data.song1.title }}',
    song2_title: '{{ match_data.song2.title }}'
});

// Add visual debug info to page
console.log('Page loaded at:', new Date().toISOString());
console.log('URL parameters:', window.location.search);
</script>
<script>
function highlightCard(cardElement) {
    cardElement.classList.add('song-card-hover');
}

function clearHighlight(cardElement) {
    cardElement.classList.remove('song-card-hover');
}

function selectSong(songId) {
    // Prevent multiple clicks during animation
    if (document.body.classList.contains('voting-in-progress')) {
        return;
    }
    
    document.body.classList.add('voting-in-progress');
    
    // Disable all cards
    document.querySelectorAll('.song-card').forEach(card => {
        card.style.pointerEvents = 'none';
    });
    
    // Start animation
    animateVoteSelection(songId);
    
    // Send vote via AJAX after 500ms to allow animation to start
    setTimeout(() => {
        fetch('{% url "cast_vote" %}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: JSON.stringify({
                session_id: '{{ match_data.session_id }}',
                chosen_song_id: songId
            })
        })
        .then(response => response.json())
        .then(data => {
            console.log('Vote response received:', data);
            
            if (data.success) {
                console.log('Vote was successful');
                console.log('Tournament completed:', data.completed);
                console.log('Next match available:', !!data.next_match);
                
                // Navigate after animation completes (2s total)
                setTimeout(() => {
                    console.log('About to navigate...');
                    console.log('Current session data:', {
                        session_id: '{{ match_data.session_id }}',
                        current_match: {{ debug_info.current_match }},
                        response_data: data
                    });
                    
                    // Add timestamp to force cache bust
                    const timestamp = new Date().getTime();
                    const voteUrl = '{% url "vote" %}';
                    const cacheBustUrl = `${voteUrl}?t=${timestamp}`;
                    
                    if (data.completed) {
                        console.log('Navigating to completion page with cache bust');
                        window.location.href = cacheBustUrl;
                    } else if (data.next_match) {
                        console.log('Navigating to next match with cache bust');
                        console.log('Expected next match data:', data.next_match);
                        window.location.href = cacheBustUrl;
                    } else {
                        console.log('No next match available - error condition');
                        alert('Error: No next match available');
                        window.location.href = '{% url "home" %}';
                    }
                }, 2000);
            } else {
                console.error('Vote failed:', data.error);
                alert('Error casting vote: ' + data.error);
                resetVotingState();
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error casting vote. Please try again.');
            resetVotingState();
        });
    }, 500);
}

function animateVoteSelection(selectedSongId) {
    const song1Card = document.getElementById('song1Card');
    const song2Card = document.getElementById('song2Card');
    const vsContainer = document.getElementById('vsContainer');
    
    // Determine which card was selected
    const song1Id = song1Card.getAttribute('data-song-id');
    const song2Id = song2Card.getAttribute('data-song-id');
    
    let selectedCard, unselectedCard;
    let isFirstCard = false;
    
    if (selectedSongId === song1Id) {
        // First card selected
        selectedCard = song1Card;
        unselectedCard = song2Card;
        isFirstCard = true;
    } else {
        // Second card selected  
        selectedCard = song2Card;
        unselectedCard = song1Card;
        isFirstCard = false;
    }
    
    // Detect if we're on mobile (screen width <= 767px)
    const isMobile = window.innerWidth <= 767;
    
    if (isMobile) {
        // Mobile: Use up/down animations
        if (isFirstCard) {
            // First card (top) selected
            selectedCard.classList.add('vote-animation-selected-top');
            unselectedCard.classList.add('vote-animation-unselected-bottom');
        } else {
            // Second card (bottom) selected
            selectedCard.classList.add('vote-animation-selected-bottom');
            unselectedCard.classList.add('vote-animation-unselected-top');
        }
        
        // Store which position was selected
        selectedCard.dataset.selectedSide = isFirstCard ? 'top' : 'bottom';
    } else {
        // Desktop/Tablet: Use left/right animations
        if (isFirstCard) {
            selectedCard.classList.add('vote-animation-selected-left');
            unselectedCard.classList.add('vote-animation-unselected-right');
        } else {
            selectedCard.classList.add('vote-animation-selected-right');
            unselectedCard.classList.add('vote-animation-unselected-left');
        }
        
        // Store which side was selected
        selectedCard.dataset.selectedSide = isFirstCard ? 'left' : 'right';
    }
    
    // Fade out VS container
    vsContainer.classList.add('vote-animation-vs');
    
    // Remove hover effects during animation
    selectedCard.classList.remove('song-card-hover');
    unselectedCard.classList.remove('song-card-hover');
}

function resetVotingState() {
    // Re-enable cards
    document.querySelectorAll('.song-card').forEach(card => {
        card.style.pointerEvents = 'auto';
    });
    
    // Remove voting progress flag
    document.body.classList.remove('voting-in-progress');
    
    // Remove animation classes (both desktop and mobile)
    const animationClasses = [
        'vote-animation-selected-left', 'vote-animation-selected-right',
        'vote-animation-unselected-left', 'vote-animation-unselected-right',
        'vote-animation-selected-top', 'vote-animation-selected-bottom',
        'vote-animation-unselected-top', 'vote-animation-unselected-bottom',
        'vote-animation-vs'
    ];
    
    document.querySelectorAll('.song-card, #vsContainer').forEach(element => {
        animationClasses.forEach(className => {
            element.classList.remove(className);
        });
        // Remove the selectedSide data attribute
        delete element.dataset.selectedSide;
    });
}

// Audio player management and cache initialization
document.addEventListener('DOMContentLoaded', function() {
    const audioElements = document.querySelectorAll('audio');
    const iframeElements = document.querySelectorAll('iframe.google-drive-audio');
    
    // Handle regular audio elements
    audioElements.forEach(audio => {
        audio.addEventListener('play', function() {
            audioElements.forEach(otherAudio => {
                if (otherAudio !== audio) {
                    otherAudio.pause();
                }
            });
            // Pause iframe audio (reload to stop)
            iframeElements.forEach(iframe => {
                iframe.src = iframe.src;
            });
        });
    });
    
    // Initialize caching system
    console.log('Initializing tournament cache system...');
    
    // Try to restore cache from localStorage first
    const cacheRestored = tournamentCache.loadFromLocalStorage();
    
    // Start immediate preloading for current match
    tournamentCache.preloadNextRoundSongs();
    
    // Start background preloading after a short delay
    setTimeout(() => {
        tournamentCache.startBackgroundPreloading();
    }, 3000); // Wait 3 seconds before starting background preloading
    
    // Preload current match resources with high priority
    const currentMatchSongs = [
        {
            background_image_url: '{{ match_data.song1.background_image_url }}',
            audio_url: '{{ match_data.song1.audio_url }}',
            title: '{{ match_data.song1.title }}'
        },
        {
            background_image_url: '{{ match_data.song2.background_image_url }}',
            audio_url: '{{ match_data.song2.audio_url }}',
            title: '{{ match_data.song2.title }}'
        }
    ];
    
    tournamentCache.preloadImages(currentMatchSongs, true);
    // Audio preloading removed - only images are cached
    
    console.log('Cache initialization completed');
    
    // Periodic cache performance reporting and persistence (every 30 seconds)
    setInterval(() => {
        tournamentCache.logCachePerformance();
        tournamentCache.clearOldCache(); // Clean up if needed
        tournamentCache.saveToLocalStorage(); // Persist cache state
    }, 30000);
    
    // Save cache when leaving page
    window.addEventListener('beforeunload', () => {
        tournamentCache.saveToLocalStorage();
    });
});

// Audio loading management
let audioLoadTimeout = null;

function loadAudioFrame(frameId, audioUrl, loadingId, fallbackButtonId) {
    const frame = document.getElementById(frameId);
    const loading = document.getElementById(loadingId);
    const fallbackButton = document.getElementById(fallbackButtonId);
    
    // Check if elements exist
    if (!frame || !loading || !fallbackButton) {
        console.error('Audio loading elements not found:', {frameId, loadingId, fallbackButtonId});
        return;
    }
    
    // Hide fallback button and show loading
    fallbackButton.classList.add('d-none');
    loading.classList.remove('d-none');
    
    let loadingComplete = false;
    
    // Set timeout to show fallback if loading takes too long (extended to 8 seconds)
    const timeout = setTimeout(() => {
        if (!loadingComplete) {
            loading.classList.add('d-none');
            fallbackButton.classList.remove('d-none');
            fallbackButton.innerHTML = '<i class="fas fa-exclamation-triangle me-1"></i> Slow connection - Retry';
        }
    }, 8000);
    
    // For Google Drive, we need to use a different approach since onload isn't reliable
    // We'll assume success after a delay and provide fallback if needed
    const assumeLoaded = setTimeout(() => {
        if (!loadingComplete) {
            loadingComplete = true;
            clearTimeout(timeout);
            loading.classList.add('d-none');
            frame.classList.remove('d-none');
            console.log('Audio assumed loaded after delay');
        }
    }, 3000);
    
    // Still try iframe events as backup
    frame.onload = () => {
        if (!loadingComplete) {
            loadingComplete = true;
            clearTimeout(timeout);
            clearTimeout(assumeLoaded);
            loading.classList.add('d-none');
            frame.classList.remove('d-none');
            console.log('Audio loaded via onload event');
        }
    };
    
    frame.onerror = () => {
        if (!loadingComplete) {
            loadingComplete = true;
            clearTimeout(timeout);
            clearTimeout(assumeLoaded);
            loading.classList.add('d-none');
            fallbackButton.classList.remove('d-none');
            fallbackButton.innerHTML = '<i class="fas fa-exclamation-triangle me-1"></i> Failed to load';
        }
    };
    
    // Start loading
    frame.src = audioUrl;
}

function loadSecondAudio(audioUrl, button) {
    const container = button.parentElement;
    const loadingDiv = document.getElementById('audioLoading2');
    const frame = document.getElementById('audioFrame2');
    const fallbackButton = document.getElementById('audioFallback2');
    
    // Check if elements exist
    if (!container || !loadingDiv || !frame) {
        console.error('Second audio loading elements not found');
        return;
    }
    
    // Hide lazy button and show loading
    container.classList.add('d-none');
    loadingDiv.classList.remove('d-none');
    
    let loadingComplete = false;
    
    // Set timeout for fallback (extended to 8 seconds)
    const timeout = setTimeout(() => {
        if (!loadingComplete) {
            loadingDiv.classList.add('d-none');
            if (fallbackButton) {
                fallbackButton.classList.remove('d-none');
            }
        }
    }, 8000);
    
    // Assume loaded after delay (same approach as first audio)
    const assumeLoaded = setTimeout(() => {
        if (!loadingComplete) {
            loadingComplete = true;
            clearTimeout(timeout);
            loadingDiv.classList.add('d-none');
            frame.classList.remove('d-none');
            console.log('Second audio assumed loaded after delay');
        }
    }, 3000);
    
    // Try iframe events as backup
    frame.onload = () => {
        if (!loadingComplete) {
            loadingComplete = true;
            clearTimeout(timeout);
            clearTimeout(assumeLoaded);
            loadingDiv.classList.add('d-none');
            frame.classList.remove('d-none');
            console.log('Second audio loaded via onload event');
        }
    };
    
    frame.onerror = () => {
        if (!loadingComplete) {
            loadingComplete = true;
            clearTimeout(timeout);
            clearTimeout(assumeLoaded);
            loadingDiv.classList.add('d-none');
            if (fallbackButton) {
                fallbackButton.classList.remove('d-none');
            }
        }
    };
    
    frame.src = audioUrl;
}

// Auto-load first audio on page load with delay
document.addEventListener('DOMContentLoaded', function() {
    // Preload next match audio if available
    if (window.tournamentCache && window.tournamentCache.preloadAudioForNextMatch) {
        setTimeout(() => {
            window.tournamentCache.preloadAudioForNextMatch();
        }, 1000);
    }
    
    // Load first audio automatically after a short delay
    setTimeout(() => {
        const firstFrame = document.getElementById('audioFrame1');
        const firstAudioUrl = firstFrame?.getAttribute('data-src');
        if (firstFrame && firstAudioUrl) {
            loadAudioFrame('audioFrame1', firstAudioUrl, 'audioLoading1', 'audioFallback1');
        }
    }, 500);
    
    // Preload second audio on hover/focus for better UX
    const secondCard = document.getElementById('song2Card');
    if (secondCard) {
        let preloaded = false;
        const preloadSecond = () => {
            if (!preloaded) {
                preloaded = true;
                const lazyButton = document.querySelector('#audioLazy2 button');
                if (lazyButton && !lazyButton.disabled) {
                    // Don't auto-click, just prepare for faster loading
                    console.log('Preparing second audio for faster loading...');
                }
            }
        };
        
        secondCard.addEventListener('mouseenter', preloadSecond, { once: true });
        secondCard.addEventListener('focus', preloadSecond, { once: true });
    }
});

// Keyboard shortcuts
document.addEventListener('keydown', function(e) {
    // Don't trigger if voting is in progress
    if (document.body.classList.contains('voting-in-progress')) {
        return;
    }
    
    if (e.key === '1' || e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
        e.preventDefault();
        selectSong('{{ match_data.song1.id }}');
    } else if (e.key === '2' || e.key === 'ArrowRight' || e.key === 'ArrowDown') {
        e.preventDefault();
        selectSong('{{ match_data.song2.id }}');
    }
});

// Handle orientation changes and window resize
let resizeTimeout;
window.addEventListener('resize', function() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(function() {
        // Reset any ongoing animations on resize to prevent layout issues
        if (document.body.classList.contains('voting-in-progress')) {
            resetVotingState();
        }
        
        // Log layout change for debugging
        const isMobile = window.innerWidth <= 767;
        console.log('Layout changed:', isMobile ? 'Mobile (vertical)' : 'Desktop (horizontal)', 
                   'Width:', window.innerWidth + 'px');
    }, 100);
});
</script>
{% endblock %}